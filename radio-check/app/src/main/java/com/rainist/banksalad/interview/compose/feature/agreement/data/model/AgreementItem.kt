package com.rainist.banksalad.interview.compose.feature.agreement.data.model

import androidx.compose.runtime.Immutable


/*
라이브 멘트 시나리오

“AgreementItem은 약관 동의 화면에서 사용하는
가장 작은 단위의 UI 모델입니다.”

“이 모델은 서버 응답 DTO가 아니라,
UI 상태를 표현하기 위한 Presentation Model로 설계했습니다.”

“그래서 UI에서 필요한 값만 명확하게 포함하고,
비즈니스 규칙 판단에 필요한 최소한의 정보만 가지고 있습니다.”
*/

//"만약 이 리스트가 매우 길고 성능이 중요하다면,
// 클래스 상단에 @Immutable 어노테이션을 붙여
// 컴포즈 컴파일러에게 이 객체가 변하지 않음을 명시적으로 알려줌으로써 재구성 최적화를 한 단계 더 높일 수 있습니다."
@Immutable
data class AgreementItem(
    /*
   “각 약관 항목을 식별하기 위한 고유 id입니다.
   RecyclerView/LazyColumn, 상태 업데이트, Intent 전달 시
   기준 키로 사용됩니다.”
   */

    val id : Int, // 각 항목 (라디오 버튼 , 선택박스) 에 대한 구분값

    /*
    “UI에 그대로 노출되는 약관 제목입니다.
    실제 서비스라면 서버에서 내려오는 문구를 그대로 매핑합니다.”
    */
    val title : String, // 제목

    /*
    “현재 사용자가 이 항목을 체크했는지 여부입니다.
    Compose에서는 이 값이 변경되면 해당 UI만 재구성됩니다.”
    */

    val isChecked : Boolean,  // 체크유무 확인

    /*
    “필수 약관인지 여부입니다.
    ‘필수 약관만 동의’ 같은 비즈니스 규칙을
    UI가 아닌 상태 레벨에서 판단하기 위해 포함했습니다.”
    */
    val isRequired: Boolean // 필수적으로 체크를 해야되나? 필수 동의 / 선택적 동의 선택 박스를 위한 값
)

/*
========================
예상 질문 & 모범 답변
========================

Q. 왜 AgreementItem을 data class로 만들었나요?
A.
“불변 객체로 상태를 관리하기 위해서입니다.
Compose와 MVI 패턴에서는
상태 변경 시 새로운 객체를 만들어 전달하는 것이
사이드 이펙트를 줄이고 추적을 쉽게 합니다.”

Q. 서버 DTO랑 분리한 이유가 있나요?
A.
“서버 모델은 언제든 변경될 수 있고,
UI는 UI에 필요한 형태가 다르기 때문입니다.
DTO → UI Model로 분리하면
UI 요구사항 변경이 서버 구조에 영향을 받지 않습니다.”

Q. id를 Int로 둔 이유는요?
A.
“과제 범위에서는 단순 식별자로 충분하다고 판단했습니다.
실서비스라면 String UUID나 서버에서 내려온 key를 그대로 사용했을 겁니다.”

Q. isRequired를 UI 모델에 둔 게 과하지 않나요?
A.
“아닙니다.
‘필수 약관만 동의’ 같은 규칙은
UI 이벤트가 아니라 상태 판단 로직이기 때문에
명시적으로 모델에 포함시키는 게 더 안전합니다.”

Q. 체크 토글 시 어떻게 상태를 업데이트하나요?
A.
“ViewModel에서 id 기준으로 해당 항목만 복사(copy)해서
새로운 agreementItems 리스트를 만들고
UiState 전체를 갱신합니다.
UI는 이 변화를 자동으로 반영합니다.”

Q. 이 모델을 sealed class로 만들지 않은 이유는요?
A.
“약관 항목 자체는 타입 분기가 필요하지 않고
동일한 속성을 공유하기 때문에
data class가 더 적절하다고 판단했습니다.”


Q1. 왜 모든 필드를 val로 선언하고 data class를 사용했나요?
✅ 모범 답변: "객체의 **상태 불변성(Immutability)**을 보장하기 위해서입니다.
var를 사용하여 내부 값을 직접 바꾸면 어디서 데이터가 변했는지 추적하기 어렵고,
특히 Jetpack Compose의 재구성(Recomposition) 알고리즘은 객체의
참조가 바뀔 때 가장 효율적으로 동작하기 때문에 copy() 메서드를 제공하는
 data class와 val의 조합이 가장 적합합니다."

Q2. id 값이 꼭 필요한가요? 그냥 리스트 인덱스로 처리하면 안 되나요?
✅ 모범 답변: "컴포즈의 LazyColumn이나 리스트 연산에서 인덱스는 위험할 수 있습니다.
리스트의 순서가 바뀌거나 항목이 추가/삭제될 때 인덱스를 키로 쓰면 컴포즈가 어떤 항목이 바뀌었는지
정확히 인지하지 못해 불필요한 재구성을 일으키거나 애니메이션이 깨질 수 있습니다.
 고유한 id를 key로 지정해야 정확하고 효율적인 UI 업데이트가 가능합니다."

Q3. 이 모델은 Domain 모델인가요, UI 모델인가요?
✅ 모범 답변: "현재는 과제 규모상 하나로 사용하고 있지만, 엄밀히 말하면 UI 모델에 가깝습니다.
실무에서는 서버에서 내려주는 데이터(DTO)와 UI에서 체크 여부를 관리하는 모델을 분리하여,
UI의 변화가 비즈니스 로직에 영향을 주지 않도록 설계하는 것을 지향합니다."
*/